Excellent. Re-theming the game provides a strong creative vision. Here is the full development plan, revised to integrate the Book of Mormon theme and your six specified factions.

---

This document outlines the development plan for **"Chronicles of the Promised Land"** (working title), a browser-first, 2.5D turn-based strategy game inspired by the narratives of *The Book of Mormon*, with core gameplay mechanics similar to *The Battle of Polytopia*.

The project will be built using a modern web stack designed for performance, scalability, and an efficient development workflow. The primary technologies are:

* **Frontend & Rendering:** TypeScript, React, and Three.js (via `@react-three/fiber`).
* **State Management:** Zustand.
* **Backend & Multiplayer:** Node.js (with Fastify or Colyseus).
* **Development Environment & Bundling:** Vite.

---

### **Phase 0: Foundation & Strategy**

This phase is about establishing the specific rules and architectural backbone for this unique world.

* **Game Design Document (GDD):**
    * This "Rules Bible" is the most critical step. It must define the precise mechanics for the six starting factions: **Nephites, Lamanites, Mulekites of Zarahemla, Anti-Nephi-Lehies, Zoramites, and Jaredites.**
    * Quantify all faction-specific attributes:
        * **Core Stats:** Define game state variables for **Faith, Pride,** and **Internal Dissent**.
        * **Unique Abilities:** Detail the exact trigger conditions, costs, and effects for abilities like the Nephite "Title of Liberty," the Lamanite "Blood Feud," the Zoramite "Rameumptom," and the Jaredite "Prophetic Collapse."
        * **Units & Victories:** Document the stats for all unique units (Stripling Warriors, Royal Envoy, etc.) and the precise conditions for each victory type (Domination, Cultural Conversion, Faith, etc.).

* **Repository & Workflow:**
    * Set up a **monorepo** using `pnpm workspaces`.
    * **/client:** Contains the React/Three.js frontend application.
    * **/server:** The authoritative Node.js server for multiplayer logic.
    * **/shared:** The most important directory. It will contain all game logic, TypeScript type definitions (`Unit`, `Tile`, `Faction`), and rule functions that can be used by *both* the client and server to ensure consistency.

* **Rendering Strategy:**
    * Focus exclusively on a single, high-performance **WebGL rendering path** using `three.js`. A fallback 2D renderer is out of scope.

---

### **Phase 1: Core Engine & Rendering**

This phase focuses on visually representing the game world and its unique inhabitants.

* **Project Scaffolding:**
    * Initialize the Vite project with the `react-ts` template and install core dependencies (`three`, `react-three-fiber`, `zustand`, etc.).
    * Configure Tailwind CSS for all UI styling.

* **Rendering Layer:**
    * **`GridManager` Component:** Renders the game world using instanced meshes for terrain types (plains, forests, mountains).
    * **`Unit` & `Structure` Components:** Create 3D models or sprites for each unique unit and structure (e.g., a Nephite temple, the Zoramite Rameumptom, city fortifications).
    * Use a **texture atlas** for all game sprites to minimize load times and improve rendering performance.

* **Game Data Management:**
    * In the `/shared/data/` directory, define all game entities as strongly-typed TypeScript objects. This provides compile-time checks and prevents data errors.
        * `factions.ts`: `export const FACTIONS = { NEPHITES: { name: 'Nephites', startingTech: '...'}, ... }`
        * `units.ts`: `export const UNITS = { STRIPLING_WARRIOR: { hp: 15, defense: 3, requiresFaith: 70 }, ... }`
        * `abilities.ts`: `export const ABILITIES = { TITLE_OF_LIBERTY: { cost: 50, effect: 'morale_boost' }, ... }`
    * Use the **Zod** library to parse this data at startup, guaranteeing 100% data integrity.

* **Save/Load System:**
    * Implement the save/load mechanism: `GameState` (from Zustand) → `JSON.stringify` → `lz-string` compression → `IndexedDB`.
    * Provide clear "Export to File" and "Import from File" buttons for user-managed backups.

---

### **Phase 2: Gameplay Logic**

This phase implements the thematic rules and mechanics defined in the GDD.

* **State Reducer:**
    * Create a single, pure `gameReducer` function in `/shared/logic/`. This is the heart of the game.
    * It will take the current state and an action and return the new state (`(currentState, action) => newState`).
    * This reducer must handle all thematic game actions, including:
        * Activating special abilities like `ACTIVATE_RAMEUMPTOM` or `USE_CULTURAL_RECLAMATION`.
        * Calculating combat damage, applying modifiers like the Lamanite "Blood Feud."
        * Processing faith-based events and scripture tech boosts.
        * Implementing the "Covenant of Peace" logic for the Anti-Nephi-Lehies, converting units instead of destroying them.
        * Tracking the "Pride" metric and triggering the Jaredite "Prophetic Collapse" event if the threshold is passed.

* **Grid & Pathfinding:**
    * Integrate an established **A\* pathfinding library**.
    * Run pathfinding in a **Web Worker** to keep the UI smooth and responsive.

* **Turn Management:**
    * Use a finite-state machine (FSM) in the Zustand store to manage the game flow: `PlayerTurn`, `ProcessingTurn`, `AITurn`, `Animating`, `GameOver`.

* **Procedural Map Generation:**
    * Execute map generation in a **Web Worker** using a seeded pseudo-random number generator for replayable maps.
    * The generation logic should create thematic terrain features like narrow necks of land, large bodies of water, and resource-rich areas.

---

### **Phase 3: Artificial Intelligence (AI)**

This phase gives each faction a distinct "personality" that reflects its identity.

* **Base AI Logic:**
    * Develop a foundational AI that can handle common tasks: exploring the map, gathering resources, evaluating basic threats, and moving units.

* **Faction Personality Overlays:**
    * Build on the base AI with specific logic modules that guide each faction's strategic decisions:
        * **Lamanite AI:** Prioritizes early-game aggression and unit production. Will actively seek combat, especially with Nephite players.
        * **Nephite AI:** Emphasizes building defensive structures (fortifications) and pursuing the tech tree to leverage scripture bonuses.
        * **Zoramite AI:** Focuses on economic growth and strategically using the "Rameumptom" ability for civic power spikes. Will be hostile to factions with low resource counts.
        * **Anti-Nephi-Lehies AI:** Avoids initiating combat at all costs. Its goal is to maximize cultural/religious influence and will only build defensive units when directly attacked.
        * **Mulekite AI:** Focuses on rapid expansion and diplomacy. Will actively seek to recover knowledge and form alliances.

---

### **Phase 4: Multiplayer**

This phase leverages the `/shared` logic to create an online experience.

* **Backend Server:**
    * Use **Colyseus**, a game-centric Node.js framework that handles room management and state synchronization, which is ideal for this project.

* **Authoritative Server Model:**
    * This architecture is non-negotiable for cheat prevention.
    * The client sends player actions (e.g., "I want to move Stripling Warriors to tile X") to the server.
    * The server validates the action using the **exact same `gameReducer`** from the `/shared` directory.
    * If valid, the server updates its `GameState` and broadcasts the new state to all clients.

* **Authentication & Persistence:**
    * Use **Firebase Auth** for secure user authentication.
    * Use **Firestore** or **Supabase (PostgreSQL)** to store user profiles and game state snapshots after each completed turn.

---

### **Phase 5: User Experience & Polish**

This phase focuses on immersing the player in the game's unique world.

* **Art & Audio:**
    * Develop an art style that evokes ancient American civilizations as described in the text.
    * The soundtrack should be thematic, with distinct musical motifs for each faction (e.g., militant drums for the Lamanites, reverent choirs for the Nephites).
    * Create unique sound effects for all special abilities and units.

* **UI/HUD:**
    * Design the UI to feel thematic. Menus could have a metallic plate or scroll motif.
    * Create custom icons and meters for **Faith** and **Pride**.

* **Narrative & Tutorial:**
    * Develop a narrative-driven tutorial. For example, have the player guide Lehi's family through the wilderness to the promised land, teaching the core mechanics of movement, resource gathering, and faith.

---

### **Phase 6: Deployment & Launch**

This final phase focuses on packaging the game and making it available to players.

* **CI/CD (Continuous Integration/Continuous Deployment):**
    * Use **GitHub Actions** to automate testing and deployment, ensuring code quality and rapid updates.

* **Hosting:**
    * **Client/Frontend:** Deploy to **Vercel** or **Cloudflare Pages** for best-in-class global performance.
    * **Server/Backend:** Deploy to a service like **Render** or **Fly.io**.

* **Progressive Web App (PWA):**
    * Use the `@vite-pwa/react` plugin to allow players to "install" the game to their home screen and enable offline access to assets.

* **Monitoring & QA:**
    * Integrate an error reporting service like **Sentry** to automatically capture errors encountered by players.
    * Test extensively on target desktop and mobile browsers.