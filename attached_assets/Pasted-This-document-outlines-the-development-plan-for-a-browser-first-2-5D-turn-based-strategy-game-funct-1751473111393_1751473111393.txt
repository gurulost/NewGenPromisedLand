This document outlines the development plan for a browser-first, 2.5D turn-based strategy game functionally equivalent to *The Battle of Polytopia*.

The project will be built using a modern web stack designed for performance, scalability, and an efficient development workflow. The primary technologies are:

* **Frontend & Rendering:** TypeScript, React, and Three.js (via `@react-three/fiber`).
* **State Management:** Zustand.
* **Backend & Multiplayer:** Node.js (with Fastify or Colyseus).
* **Development Environment & Bundling:** Vite.

---

### **Phase 0: Foundation & Strategy**

This initial phase establishes the architectural backbone and core principles for the entire project.

* **Game Design Document (GDD):**
    * Finalize and document the "rules bible" for the game. This includes precise stats for all units (HP, attack, defense, movement), technologies, buildings, and resources.
    * Define the exact formulas for combat, resource generation, and scoring. This precision is essential for the developer to implement the game logic correctly.
    * Document browser-specific user interactions, such as "tap-to-select, tap-to-move" for touch and "click-and-drag" for mouse-based map panning.

* **Repository & Workflow:**
    * Set up a **monorepo** using `pnpm workspaces`. This structure is ideal for sharing code between the client and server.
    * **/client:** Contains the React/Three.js frontend application.
    * **/server:** The authoritative Node.js server for multiplayer logic.
    * **/shared:** The most critical directory. It will contain all game logic, TypeScript type definitions (`Unit`, `Tile`, `GameState`), and rule functions that can be used by *both* the client and server to ensure consistency.

* **Rendering Strategy:**
    * Focus exclusively on a single, high-performance **WebGL rendering path** using `three.js`.
    * A fallback 2D canvas renderer adds significant complexity and should be considered out of scope for the initial version.

---

### **Phase 1: Core Engine & Rendering**

This phase focuses on getting a visible grid and game objects on the screen, forming the visual foundation of the game.

* **Project Scaffolding:**
    * Initialize the Vite project with the `react-ts` template.
    * Install core dependencies: `three`, `@types/three`, `@react-three/fiber`, `@react-three/drei`, and `zustand`.
    * Configure Tailwind CSS for all UI styling.

* **Rendering Layer:**
    * **`GridManager` Component:** The main component responsible for rendering the game world.
    * **`Tile` Component:** Use a single `InstancedMesh` for each terrain type (e.g., one mesh for all grass tiles, one for all water). This is the most performant way to render a large grid.
    * **`Unit` Component:** Render units on top of the tiles. These can be individual components initially, as the number of units is much lower than tiles.
    * Use a **texture atlas** (a single image file containing multiple smaller textures) for all game sprites to minimize load times and improve rendering performance.

* **Game Data Management:**
    * Create a `/shared/data/` directory to hold all static game data.
    * Define game entities as strongly-typed TypeScript objects (e.g., `export const UNITS = { warrior: { hp: 10, ... } };`). This provides compile-time checks.
    * Use a validation library like **Zod** to parse this data at startup. This ensures 100% data integrity and prevents bugs from malformed data.

* **Save/Load System:**
    * Implement the save/load mechanism: `GameState` (from Zustand) → `JSON.stringify` → `lz-string` compression → `IndexedDB`.
    * Use the `idb-keyval` library to greatly simplify interactions with IndexedDB.
    * Provide clear "Export to File" and "Import from File" buttons for robust, user-managed backups.

---

### **Phase 2: Gameplay Logic**

With a visual engine in place, this phase implements the core rules of the game within the `/shared` directory.

* **State Reducer:**
    * Create a single, pure `gameReducer` function. A pure function is critical because it has no side effects, making it perfectly predictable and testable.
    * This function will follow the pattern: `(currentState, action) => newState`.
    * **Example Action:** `{ type: 'MOVE_UNIT', payload: { unitId: '...', targetTile: '...' } }`.
    * This central function will house all game rules: movement validation, combat calculations, and resource harvesting. It is the heart of the game's logic.

* **Grid & Pathfinding:**
    * Integrate an established **A\* pathfinding library**. Do not build this from scratch.
    * Run all pathfinding calculations inside a **Web Worker**. This prevents complex calculations on large maps from freezing the UI, ensuring the game always feels responsive.

* **Turn Management:**
    * Use a finite-state machine (FSM) within the Zustand store to manage the game flow.
    * **Define States:** `Initializing`, `PlayerTurn`, `ProcessingTurn`, `AITurn`, `Animating`, `GameOver`.
    * The UI will reactively render based on the current state (e.g., the "End Turn" button is only visible during `PlayerTurn`).

* **Procedural Map Generation:**
    * Execute the entire map generation process in a **Web Worker**.
    * The pipeline must be deterministic, using a seeded pseudo-random number generator (`seedrandom`) so that a given seed always produces the same map.
    * The worker will generate the map data and send the final array of tiles back to the main thread for rendering.

---

### **Phase 3: Artificial Intelligence (AI)**

This phase brings the single-player experience to life. The key is to start simple and iterate.

* **Level 1 AI (Reactive):**
    * Implement a simple, rule-based AI that is fast and predictable.
    * The AI makes decisions based on a prioritized checklist:
        1.  If an enemy is in attack range, attack it.
        2.  If a city can be captured, move towards it.
        3.  Otherwise, explore the nearest fog-of-war tile.
    * This provides a functional opponent without the complexity of deep strategic analysis.

* **Level 2 AI (Utility-Based):**
    * Implement a more advanced AI that scores every possible action.
    * For each unit and each potential move, calculate a "utility score" based on factors like enemy threat, resource value of the target tile, and strategic position.
    * The AI executes the action with the highest calculated score.
    * **Difficulty Tiers** can be easily implemented by adjusting the AI's scoring parameters or giving it a small resource handicap/bonus.

---

### **Phase 4: Multiplayer**

This phase leverages the `/shared` logic to create an online experience with a cheat-resistant architecture.

* **Backend Server:**
    * Use a modern Node.js framework. **Colyseus** is highly recommended as it's a game-centric framework that handles room management and state synchronization out-of-the-box, saving significant development time. Alternatively, use **Fastify** with `@fastify/websocket` for a more custom solution.

* **Authoritative Server Model:**
    * This architecture is non-negotiable for cheat prevention.
    * The client **sends player actions** (intents) to the server, not state changes.
    * The server validates the action using the **exact same `gameReducer`** from the `/shared` directory.
    * If the action is valid, the server updates its authoritative `GameState` and broadcasts the new state to all clients in that game.

* **Authentication & Persistence:**
    * Use **Firebase Auth** for a secure and easy-to-implement user authentication system (email, Google, etc.).
    * Use **Firestore** or **Supabase (PostgreSQL)** to store user profiles and game state snapshots after each completed turn.

---

### **Phase 5: User Experience & Polish**

This phase focuses on what makes a game feel fun and engaging, not just functional.

* **Game Feel & "The Juice":**
    * **Animations:** Use a tweening library like `GSAP` for all visual changes. Units must slide smoothly between tiles; health bars should animate down when taking damage.
    * **Feedback:** Provide immediate visual and audio feedback for every action: a sound for selecting a unit, a visual effect for combat, a confirmation sound for ending a turn.
    * **UI Transitions:** All menus and UI elements should fade or slide in and out gracefully.

* **Input Handling:**
    * Create a unified input manager that handles **mouse, keyboard, and touch controls**. It should translate different physical inputs into standardized game actions (e.g., `selectTile`, `panCamera`).

* **Accessibility (A11y):**
    * Ensure all interactive elements have proper ARIA labels for screen readers.
    * Implement a high-contrast color palette option.
    * Guarantee that the entire game can be played using only a keyboard.

---

### **Phase 6: Deployment & Launch**

This final phase focuses on packaging the game and making it available to players.

* **CI/CD (Continuous Integration/Continuous Deployment):**
    * Use **GitHub Actions** to automate testing and deployment.
    * On every code push, automatically run the linter, unit tests, and a project build to catch errors immediately.
    * On a merge to the `main` branch, automatically deploy the new version to the hosting providers.

* **Hosting:**
    * **Client/Frontend:** Deploy to a static hosting provider like **Vercel** or **Cloudflare Pages** for best-in-class global performance.
    * **Server/Backend:** Deploy to a service like **Render** or **Fly.io**, which are optimized for running Node.js applications and databases.

* **Progressive Web App (PWA):**
    * Use the `@vite-pwa/react` plugin to easily add PWA capabilities.
    * Configure a service worker to aggressively cache all game assets (`Cache-first` strategy). This enables near-instant load times on subsequent visits and provides a foundation for offline play.

* **Monitoring & QA:**
    * Integrate an error reporting service like **Sentry**. It will automatically capture and report any errors that players encounter in the live game.
    * Perform final testing on a matrix of target devices: desktop Chrome/Firefox/Safari and mobile iOS/Android.