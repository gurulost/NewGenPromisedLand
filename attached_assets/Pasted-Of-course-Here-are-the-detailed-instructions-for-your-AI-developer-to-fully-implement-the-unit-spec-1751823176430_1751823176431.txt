Of course. Here are the detailed instructions for your AI developer to fully implement the unit-specific abilities.

### **Objective: Implement Functional Unit Abilities**

The game defines several unique unit abilities in `units.ts`, but the logic for these abilities is incomplete. The goal is to make these abilities fully functional, ensuring that when a player triggers an ability from the UI, its effects are correctly applied to the game state and reflected in the gameplay.

-----

### **High-Level Implementation Plan**

The primary issue is that while the UI (`UnitActionsPanel.tsx`) dispatches actions for abilities like "Heal" and "Stealth," the core game logic (`gameReducer.ts`) does not fully process these actions or update the game state accordingly.

#### **1. Implement Ability Logic in `gameReducer.ts`**

This is the most critical step. The reducer must be updated to handle the logic for each specific unit ability.

  * **Create dedicated case statements for each ability action type** (e.g., `HEAL_UNIT`, `APPLY_STEALTH`).
  * Within each case, you will need to:
    1.  Find the specific unit in the game state that is performing the action.
    2.  Apply the ability's effects to that unit or other target units.
    3.  Update the game state immutably.

**Example Implementation for "Heal":**

The "Heal" ability should restore a unit's health.

```typescript
// In gameReducer.ts, within the reducer function

case 'HEAL_UNIT': {
  const { unitId } = action.payload;

  return {
    ...state,
    units: state.units.map(unit => {
      if (unit.id === unitId) {
        // Ensure unit can heal (e.g., is in friendly territory, hasn't moved)
        // Add logic here to check conditions if necessary

        // Calculate new health, capped at maxHealth
        const newHealth = Math.min(unit.health + 10, unit.maxHealth); // Heal for 10 HP

        // Mark the unit as having performed its action for the turn
        return { ...unit, health: newHealth, hasAttacked: true };
      }
      return unit;
    }),
  };
}
```

**Example Implementation for "Stealth":**

The "Stealth" ability should make a unit invisible to enemies until it attacks.

```typescript
// In gameReducer.ts, within the reducer function

case 'APPLY_STEALTH': {
  const { unitId } = action.payload;

  return {
    ...state,
    units: state.units.map(unit => {
      if (unit.id === unitId) {
        // Apply a 'stealth' status effect
        // Mark the unit as having performed its action for the turn
        return { ...unit, status: 'stealthed', hasAttacked: true };
      }
      return unit;
    }),
  };
}
```

  * **Update Combat Logic:** You must also modify the combat logic to account for these new states. For example, a "stealthed" unit should not be targetable by enemy attacks, and attacking should remove the "stealth" status.

#### **2. Conditionally Render Actions in `UnitActionsPanel.tsx`**

The UI should be smart enough to only show abilities when they are usable.

  * **Fetch Unit Data:** The component should have access to the full state of the selected unit.
  * **Add Conditional Logic:** Wrap the buttons for each ability in a condition that checks if the action is valid.

**Example for "Heal" Button:**

Only show the "Heal" button if the unit is damaged and hasn't already acted this turn.

```tsx
// In UnitActionsPanel.tsx

{selectedUnit.health < selectedUnit.maxHealth && !selectedUnit.hasAttacked && (
  <button onClick={() => dispatch({ type: 'HEAL_UNIT', payload: { unitId: selectedUnit.id } })}>
    Heal
  </button>
)}
```

**Example for "Stealth" Button:**

Only show the "Stealth" button for units that have the ability and are not already stealthed.

```tsx
// In UnitActionsPanel.tsx

{selectedUnit.abilities.includes('stealth') && selectedUnit.status !== 'stealthed' && (
  <button onClick={() => dispatch({ type: 'APPLY_STEALTH', payload: { unitId: selectedUnit.id } })}>
    Stealth
  </button>
)}
```

#### **3. Update Unit Rendering to Reflect Status**

Players need visual feedback on the map to understand unit statuses.

  * **Modify Unit Component:** The component that renders a single unit on the map should check for status effects.
  * **Apply Visual Changes:** Use CSS classes or conditional styling to change the appearance of a unit based on its status (e.g., add a green cross for a healing unit, make a stealthed unit semi-transparent).

By following these steps, your developer can systematically implement each unit ability, connecting the UI actions to concrete changes in the game's logic and state.