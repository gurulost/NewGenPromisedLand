Based on the Polytopia gameplay video and your current camera implementation in `GameCanvas.tsx`, here are the key differences and a set of actionable directions for your developer to make your game's camera navigation feel more like Polytopia.

The core issue is that your game currently uses the default `OrbitControls` which allow for free 3D rotation, while Polytopia uses a more constrained, fixed-angle isometric view that only allows for panning and zooming.

Here are the directions to give your developer:

-----

### **Developer Directions: Improving Camera Controls**

Our goal is to replicate the camera and navigation feel of Polytopia. This means moving from free orbit controls to a fixed-angle view with smooth panning, zooming, and automatic centering on action. All of the following changes will likely be in the **`client/src/components/game/GameCanvas.tsx`** file.

**1. Disable Camera Rotation**

This is the most critical change. Polytopia's camera does not rotate. The user can pan and zoom, but the viewing angle remains constant.

  * In the `<OrbitControls>` component props, set `enableRotate` to `false`.

<!-- end list -->

```typescript
// In client/src/components/game/GameCanvas.tsx

<OrbitControls
  ref={controlsRef}
  target={[0, 0, 0]}
  enablePan={true}
  enableZoom={true}
  enableRotate={false} // <--- CHANGE THIS TO FALSE
/>
```

**2. Lock the Camera Angle**

Disabling rotation prevents the user from changing the angle, but we should also programmatically lock it to ensure consistency. This will prevent any accidental angle changes and maintain the desired isometric perspective.

  * In `<OrbitControls>`, set `minPolarAngle` and `maxPolarAngle` to the same value to lock the vertical angle. A good starting point is `Math.PI / 4` (a 45-degree angle). You can adjust this value to find the perfect feel.
  * Similarly, set `minAzimuthAngle` and `maxAzimuthAngle` to lock the horizontal rotation if needed, although disabling rotation is often sufficient.

<!-- end list -->

```typescript
// In client/src/components/game/GameCanvas.tsx

<OrbitControls
  ref={controlsRef}
  //... other props
  enableRotate={false}
  minPolarAngle={Math.PI / 4} // <--- ADD THIS
  maxPolarAngle={Math.PI / 4} // <--- AND THIS (lock vertical angle)
/>
```

**3. Refine Panning and Zoom**

Polytopia has smooth, responsive panning (click/touch and drag) and a constrained zoom.

  * **Panning:** The current `enablePan={true}` is correct. Ensure this feels fluid.
  * **Zoom:** The current `minDistance` and `maxDistance` props control the zoom level. Adjust these values based on your map size to prevent the user from zooming too far out or uncomfortably close.

<!-- end list -->

```typescript
// In client/src/components/game/GameCanvas.tsx

<OrbitControls
  ref={controlsRef}
  //... other props
  minDistance={8}   // <--- ADJUST AS NEEDED
  maxDistance={50}  // <--- ADJUST AS NEEDED
/>
```

**4. (Advanced) Implement Smooth Camera Centering**

A key feature of Polytopia's UI is that the camera automatically animates to focus on the action, such as when a unit is selected or a turn begins. This requires a new function to smoothly move the camera's "target".

Your project already includes `gsap` as a dependency, which is perfect for this.

  * **Create an animation function:** In `GameCanvas.tsx`, create a function that takes a target position (`THREE.Vector3`) and animates the `controlsRef.current.target` to that position using `gsap`.

  * **Trigger the animation:** Use a `useEffect` hook to watch for changes in `selectedUnit` or the `currentPlayerIndex`. When these change, call your new animation function with the coordinates of the new unit or the player's capital city.

**Example Implementation Snippet:**

```typescript
// In client/src/components/game/GameCanvas.tsx
import { gsap } from "gsap";
import { useLocalGame } from "../../lib/stores/useLocalGame";
import { useGameState }s from "../../lib/stores/useGameState";

// ... inside the GameCanvas component

const { gameState } = useLocalGame();
const { selectedUnit } = useGameState();
const controlsRef = useRef<any>();

// This effect will run whenever the selected unit changes
useEffect(() => {
  if (selectedUnit && controlsRef.current) {
    const pixelPos = hexToPixel(selectedUnit.coordinate, 1);
    const targetPosition = new THREE.Vector3(pixelPos.x, 0, pixelPos.y);

    // Use GSAP to animate the camera target
    gsap.to(controlsRef.current.target, {
      x: targetPosition.x,
      y: targetPosition.y,
      z: targetPosition.z,
      duration: 0.5, // Animation duration in seconds
      ease: "power2.inOut",
    });
  }
}, [selectedUnit]);
```

By implementing these changes, your game's navigation will feel much more polished and aligned with the intuitive, user-friendly style of Polytopia.