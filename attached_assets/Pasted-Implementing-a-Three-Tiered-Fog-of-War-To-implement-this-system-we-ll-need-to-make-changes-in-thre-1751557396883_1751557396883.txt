Implementing a Three-Tiered Fog of War

To implement this system, we'll need to make changes in three key areas: the shared data structures, the server-side game logic, and the client-side rendering.

1. Update Shared Data Structures

First, we need a way for each player to track the visibility state of every tile.

In the shared directory, modify the game state to include a visibility map for each player. A good approach is to add a visibility object to the main GameState type in shared/types/index.ts. This object can map each player's ID to a 2D array or map representing the board.

TypeScript
// In shared/types/index.ts

export const TILE_VISIBILITY = {
  UNEXPLORED: 0,
  EXPLORED: 1,
  VISIBLE: 2,
} as const;

export type TileVisibility = (typeof TILE_VISIBILITY)[keyof typeof TILE_VISIBILITY];

// ... inside the GameState type definition
export type GameState = {
  // ... other properties
  players: Player[];
  visibility: {
    [playerId: string]: TileVisibility[][]; // or a flat array, or a Map
  };
};
2. Implement Server-Side Visibility Logic

The server must be the single source of truth for what each player can see. This logic should run at the start of each player's turn.

In shared/logic/game.ts (or a new dedicated file like shared/logic/visibility.ts), create a function to calculate a player's visibility.

This function, let's call it calculateVisibility(gameState, playerId), should:

Start by setting all currently VISIBLE tiles for that player to EXPLORED. This handles the "memory" aspectâ€”tiles don't become unexplored again unless you're starting a new game.

Iterate through all of that player's units on the board.

For each unit, get its visionRange (you'll need to add this property to the unit stats in shared/data/units.ts).

Calculate all hexes within the unit's visionRange. You can use the existing getHexesInRange utility for this.

Set the visibility state for all of those calculated hexes to VISIBLE.

Update the main game reducer in shared/logic/gameReducer.ts to call this calculateVisibility function at the beginning of each turn.

TypeScript
// Example of what the logic might look like in a new `visibility.ts` file

import { GameState, Player, TileVisibility, TILE_VISIBILITY } from "../types";
import { getHexesInRange } from "../utils/hexUtils";
import { getUnitData } from "../data/units";

export function calculateVisibility(
  gameState: GameState,
  playerId: string
): TileVisibility[][] {
  const playerVisibility = gameState.visibility[playerId];

  // 1. Reset currently visible tiles to explored
  for (let r = 0; r < playerVisibility.length; r++) {
    for (let q = 0; q < playerVisibility[r].length; q++) {
      if (playerVisibility[r][q] === TILE_VISIBILITY.VISIBLE) {
        playerVisibility[r][q] = TILE_VISIBILITY.EXPLORED;
      }
    }
  }

  // 2. Set new visible tiles based on unit vision
  gameState.units.forEach((unit) => {
    if (unit.ownerId === playerId) {
      const unitData = getUnitData(unit.type);
      const visionRange = unitData.visionRange; // <-- Add this to unit data
      const visibleHexes = getHexesInRange(unit.coordinate, visionRange);

      visibleHexes.forEach((hex) => {
        // Update the visibility map for the hex coordinate
        playerVisibility[hex.r][hex.q] = TILE_VISIBILITY.VISIBLE;
      });
    }
  });

  return playerVisibility;
}
3. Update Client-Side Rendering

Finally, the client needs to render the tiles and units according to the visibility map.

In client/src/components/game/HexGridInstanced.tsx, access the visibility map for the current player.

In the rendering loop for tiles, check the visibility status:

If a tile is UNEXPLORED, render a "cloud" or a darkened/desaturated hex instead of the actual terrain.

If EXPLORED or VISIBLE, render the terrain normally.

Modify the unit rendering loop:

Only render units that are on a VISIBLE tile. Do not render units on EXPLORED or UNEXPLORED tiles.

TypeScript
// In client/src/components/game/HexGridInstanced.tsx

// ... inside the component, get the visibility for the current player
const currentPlayerId = "player1"; // Get this from your game/auth state
const visibilityMap = gameState.visibility[currentPlayerId];

// ... inside the useMemo for tiles
const tileInstances = useMemo(() => {
  const instances: TileInstance[] = [];
  gameState.tiles.forEach((tile) => {
    const visibility = visibilityMap[tile.coordinate.r][tile.coordinate.q];

    if (visibility === TILE_VISIBILITY.UNEXPLORED) {
      // Add logic to render a cloud/fog tile
      // You might need a separate InstancedMesh for this
    } else {
      // Render the tile as normal (explored or visible)
      // You could add a slight tint here for "explored" tiles if desired
    }
  });
  return instances;
}, [gameState.tiles, visibilityMap]);

// ... inside the useMemo for units
const unitInstances = useMemo(() => {
  const instances: UnitInstance[] = [];
  gameState.units.forEach((unit) => {
    const visibility = visibilityMap[unit.coordinate.r][unit.coordinate.q];

    // ONLY render the unit if the tile is VISIBLE
    if (visibility === TILE_VISIBILITY.VISIBLE) {
      // ... existing unit instance logic
    }
  });
  return instances;
}, [gameState.units, visibilityMap]);
By following these steps, you'll have a robust fog of war system that dramatically improves the strategic depth and player experience of your game.